
namespace TCRM.Task;

// Config

enum StreamSource: byte {
  Stdout = 0,
  Stderr = 1
}

table TaskConfig {
  command: string (required);
  args: [string];
  working_dir: string;
  env: [EnvEntry];
  timeout_ms: ulong;
  enable_stdin: bool = false;
  ready_indicator: string;
  ready_indicator_source: StreamSource = Stdout;

}

table EnvEntry {
  key: string (required);
  value: string (required);
}

// State

enum TaskState: byte {
  Pending = 0,
  Initiating = 1,
  Running = 2,
  Ready = 3,
  Finished = 4
}


// Error

enum TaskErrorType: byte {
  IO = 0,
  Handle = 1,
  Channel = 2,
  InvalidConfiguration = 3,
}

table TaskError {
  kind: TaskErrorType;
  message: string;
}

// Event

enum TaskTerminateReason: byte {
  Timeout = 0,
  Cleanup = 1,
  DependenciesFinished = 2,
  UserRequested = 3,
}

union TaskEventStopReason {
  Finished: DummyTable,
  TerminatedTimeout: DummyTable,
  TerminatedCleanup: DummyTable,
  TerminatedDependenciesFinished: DummyTable,
  TerminatedUserRequested: DummyTable,
  Error: ErrorStopReason
}
table DummyTable {}

table ErrorStopReason {
  message: string (required);
}


union TaskEventUnion {
  Started: StartedEvent,
  Output: OutputEvent,
  Ready: ReadyEvent,
  Stopped: StoppedEvent,
  Error: ErrorEvent
}
table StartedEvent {
  task_name: string (required);
}

table OutputEvent {
  task_name: string (required);
  line: string (required);
  src: StreamSource = Stdout;
}

table ReadyEvent {
  task_name: string (required);
}

table StoppedEvent {
  task_name: string (required);
  exit_code: int;
  reason: TaskEventStopReason (required);
}

table ErrorEvent {
  task_name: string (required);
  error: TaskError (required);
}


table TaskEvent {
  event: TaskEventUnion;
}

root_type TaskEvent;