// Import the Task namespace types
include "tcrm_task.fbs";

namespace TCRM.Monitor;

// Error types

table ConfigParseError {
  message: string (required);
}

table CircularDependencyError {
  task_name: string (required);
}

table DependencyNotFoundError {
  dependency_task_name: string (required);
  task_name: string (required);
}

enum SendStdinErrorReason: byte {
  TaskNotFound = 0,
  StdinNotEnabled = 1,
  TaskNotActive = 2,
  ChannelClosed = 3
}

table SendStdinError {
  reason: SendStdinErrorReason;
  task_name: string (required);
}

table ControlCommandError {
  terminate_all_tasks_reason: string;
  terminate_task_name: string;
  terminate_task_reason: string;
  send_stdin_task_name: string;
  send_stdin_input: string;
  send_stdin_reason: SendStdinErrorReason;
}

union TaskMonitorError {
  ConfigParse: ConfigParseError,
  CircularDependency: CircularDependencyError,
  DependencyNotFound: DependencyNotFoundError,
  ControlError: ControlCommandError,
  TaskError: TCRM.Task.TaskError
}

// Event types

enum TaskMonitorControlType: byte {
  TerminateAllTasks = 0,
  TerminateTask = 1,
  SendStdin = 2
}

table ExecutionStartedEvent {
  total_tasks: uint32;
}

table ExecutionCompletedEvent {
  completed_tasks: uint32;
  failed_tasks: uint32;
}

table ControlReceivedEvent {
  control: TaskMonitorControlCommand (required);
}

table ControlProcessedEvent {
  control: TaskMonitorControlCommand (required);
}

table TaskMonitorControlCommand {
  command_type: TaskMonitorControlType;
  task_name: string; // Used for TerminateTask and SendStdin
  input: string; // Used for SendStdin
}

table TaskTerminationRequestedEvent {
  task_name: string (required);
}

table StdinSentEvent {
  task_name: string (required);
  input_length: uint32;
}

table StdinErrorEvent {
  task_name: string (required);
  error: SendStdinErrorReason;
}
enum TaskMonitorControlEventType: byte {
  ControlReceived = 0,
  ControlProcessed = 1
}

table TaskMonitorControlEvent {
  event_type: TaskMonitorControlEventType;
  control: TaskMonitorControlCommand;
}

table TaskMonitorErrorWrapper {
  error: TaskMonitorError;
}
union TaskMonitorEvent {
  Task: TCRM.Task.TaskEvent,
  ExecutionStarted: ExecutionStartedEvent,
  ExecutionCompleted: ExecutionCompletedEvent,
  Control: TaskMonitorControlEvent,
  Error: TaskMonitorErrorWrapper
}

table TaskMonitorEventMessage {
  event: TaskMonitorEvent (required);
}

// Configuration Types

enum TaskShell: byte {
  None = 0,
  Auto = 1,
  Cmd = 2,      // Windows only
  Powershell = 3, // Windows only
  Bash = 4,     // Unix only
  Sh = 5,       // Unix only (POSIX shell)
  Zsh = 6,      // Unix only (Z shell)
  Fish = 7      // Unix only (Friendly interactive shell)
}

table TaskSpec {
  config: TCRM.Task.TaskConfig (required);
  shell: TaskShell = None;
  // pty: bool = false;
  dependencies: [string];
  terminate_after_dependents_finished: bool = false;
  ignore_dependencies_error: bool = false;
}

table TaskEntry {
  name: string (required);
  spec: TaskSpec (required);
}

table TcrmTasks {
  tasks: [TaskEntry];
}


root_type TcrmTasks;