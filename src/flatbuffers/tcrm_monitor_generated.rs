// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;
use tcrm_task::flatbuffers::tcrm_task_generated::*;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tcrm {

    use core::cmp::Ordering;
    use core::mem;
    use tcrm_task::flatbuffers::tcrm_task_generated::*;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod monitor {

        use core::cmp::Ordering;
        use core::mem;
        use tcrm_task::flatbuffers::tcrm_task_generated::{
            tcrm::task::{StreamSource, TaskConfig},
            *,
        };

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_MONITOR_ERROR: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_MONITOR_ERROR: u8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_MONITOR_ERROR: [TaskMonitorError; 5] = [
            TaskMonitorError::NONE,
            TaskMonitorError::ConfigParse,
            TaskMonitorError::CircularDependency,
            TaskMonitorError::DependencyNotFound,
            TaskMonitorError::TaskError,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskMonitorError(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskMonitorError {
            pub const NONE: Self = Self(0);
            pub const ConfigParse: Self = Self(1);
            pub const CircularDependency: Self = Self(2);
            pub const DependencyNotFound: Self = Self(3);
            pub const TaskError: Self = Self(4);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::ConfigParse,
                Self::CircularDependency,
                Self::DependencyNotFound,
                Self::TaskError,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::ConfigParse => Some("ConfigParse"),
                    Self::CircularDependency => Some("CircularDependency"),
                    Self::DependencyNotFound => Some("DependencyNotFound"),
                    Self::TaskError => Some("TaskError"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskMonitorError {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskMonitorError {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskMonitorError {
            type Output = TaskMonitorError;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl flatbuffers::EndianScalar for TaskMonitorError {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskMonitorError {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskMonitorError {}
        pub struct TaskMonitorErrorUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_SHELL: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_SHELL: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_SHELL: [TaskShell; 5] = [
            TaskShell::None,
            TaskShell::Auto,
            TaskShell::Cmd,
            TaskShell::Powershell,
            TaskShell::Bash,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskShell(pub i8);
        #[allow(non_upper_case_globals)]
        impl TaskShell {
            pub const None: Self = Self(0);
            pub const Auto: Self = Self(1);
            pub const Cmd: Self = Self(2);
            pub const Powershell: Self = Self(3);
            pub const Bash: Self = Self(4);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::None,
                Self::Auto,
                Self::Cmd,
                Self::Powershell,
                Self::Bash,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::None => Some("None"),
                    Self::Auto => Some("Auto"),
                    Self::Cmd => Some("Cmd"),
                    Self::Powershell => Some("Powershell"),
                    Self::Bash => Some("Bash"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskShell {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskShell {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskShell {
            type Output = TaskShell;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl flatbuffers::EndianScalar for TaskShell {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskShell {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskShell {}
        pub enum ConfigParseErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ConfigParseError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ConfigParseError<'a> {
            type Inner = ConfigParseError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> ConfigParseError<'a> {
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ConfigParseError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ConfigParseErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<ConfigParseError<'bldr>> {
                let mut builder = ConfigParseErrorBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn message(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            ConfigParseError::VT_MESSAGE,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ConfigParseError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ConfigParseErrorArgs<'a> {
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for ConfigParseErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                ConfigParseErrorArgs {
                    message: None, // required field
                }
            }
        }

        pub struct ConfigParseErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConfigParseErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ConfigParseError::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ConfigParseErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ConfigParseErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ConfigParseError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, ConfigParseError::VT_MESSAGE, "message");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ConfigParseError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ConfigParseError");
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum CircularDependencyErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CircularDependencyError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CircularDependencyError<'a> {
            type Inner = CircularDependencyError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CircularDependencyError<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CircularDependencyError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CircularDependencyErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<CircularDependencyError<'bldr>> {
                let mut builder = CircularDependencyErrorBuilder::new(_fbb);
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            CircularDependencyError::VT_TASK_NAME,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for CircularDependencyError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct CircularDependencyErrorArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for CircularDependencyErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                CircularDependencyErrorArgs {
                    task_name: None, // required field
                }
            }
        }

        pub struct CircularDependencyErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CircularDependencyErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    CircularDependencyError::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CircularDependencyErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CircularDependencyErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CircularDependencyError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, CircularDependencyError::VT_TASK_NAME, "task_name");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CircularDependencyError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CircularDependencyError");
                ds.field("task_name", &self.task_name());
                ds.finish()
            }
        }
        pub enum DependencyNotFoundErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DependencyNotFoundError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DependencyNotFoundError<'a> {
            type Inner = DependencyNotFoundError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> DependencyNotFoundError<'a> {
            pub const VT_DEPENDENCY: flatbuffers::VOffsetT = 4;
            pub const VT_TASK: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DependencyNotFoundError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args DependencyNotFoundErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<DependencyNotFoundError<'bldr>> {
                let mut builder = DependencyNotFoundErrorBuilder::new(_fbb);
                if let Some(x) = args.task {
                    builder.add_task(x);
                }
                if let Some(x) = args.dependency {
                    builder.add_dependency(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn dependency(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            DependencyNotFoundError::VT_DEPENDENCY,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn task(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            DependencyNotFoundError::VT_TASK,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for DependencyNotFoundError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "dependency",
                        Self::VT_DEPENDENCY,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("task", Self::VT_TASK, true)?
                    .finish();
                Ok(())
            }
        }
        pub struct DependencyNotFoundErrorArgs<'a> {
            pub dependency: Option<flatbuffers::WIPOffset<&'a str>>,
            pub task: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for DependencyNotFoundErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                DependencyNotFoundErrorArgs {
                    dependency: None, // required field
                    task: None,       // required field
                }
            }
        }

        pub struct DependencyNotFoundErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DependencyNotFoundErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_dependency(&mut self, dependency: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DependencyNotFoundError::VT_DEPENDENCY,
                    dependency,
                );
            }
            #[inline]
            pub fn add_task(&mut self, task: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DependencyNotFoundError::VT_TASK,
                    task,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> DependencyNotFoundErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                DependencyNotFoundErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DependencyNotFoundError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, DependencyNotFoundError::VT_DEPENDENCY, "dependency");
                self.fbb_
                    .required(o, DependencyNotFoundError::VT_TASK, "task");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DependencyNotFoundError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DependencyNotFoundError");
                ds.field("dependency", &self.dependency());
                ds.field("task", &self.task());
                ds.finish()
            }
        }
        pub enum TaskErrorWrapperOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskErrorWrapper<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskErrorWrapper<'a> {
            type Inner = TaskErrorWrapper<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TaskErrorWrapper<'a> {
            pub const VT_ERROR_MESSAGE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskErrorWrapper { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskErrorWrapperArgs<'args>,
            ) -> flatbuffers::WIPOffset<TaskErrorWrapper<'bldr>> {
                let mut builder = TaskErrorWrapperBuilder::new(_fbb);
                if let Some(x) = args.error_message {
                    builder.add_error_message(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn error_message(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            TaskErrorWrapper::VT_ERROR_MESSAGE,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TaskErrorWrapper<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "error_message",
                        Self::VT_ERROR_MESSAGE,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskErrorWrapperArgs<'a> {
            pub error_message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for TaskErrorWrapperArgs<'a> {
            #[inline]
            fn default() -> Self {
                TaskErrorWrapperArgs {
                    error_message: None, // required field
                }
            }
        }

        pub struct TaskErrorWrapperBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskErrorWrapperBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_error_message(&mut self, error_message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskErrorWrapper::VT_ERROR_MESSAGE,
                    error_message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskErrorWrapperBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskErrorWrapperBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskErrorWrapper<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, TaskErrorWrapper::VT_ERROR_MESSAGE, "error_message");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskErrorWrapper<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskErrorWrapper");
                ds.field("error_message", &self.error_message());
                ds.finish()
            }
        }
        pub enum TaskSpecOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskSpec<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskSpec<'a> {
            type Inner = TaskSpec<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TaskSpec<'a> {
            pub const VT_CONFIG: flatbuffers::VOffsetT = 4;
            pub const VT_SHELL: flatbuffers::VOffsetT = 6;
            pub const VT_PTY: flatbuffers::VOffsetT = 8;
            pub const VT_DEPENDENCIES: flatbuffers::VOffsetT = 10;
            pub const VT_READY_INDICATOR: flatbuffers::VOffsetT = 12;
            pub const VT_READY_INDICATOR_SOURCE: flatbuffers::VOffsetT = 14;
            pub const VT_TERMINATE_AFTER_DEPENDENTS_FINISHED: flatbuffers::VOffsetT = 16;
            pub const VT_IGNORE_DEPENDENCIES_ERROR: flatbuffers::VOffsetT = 18;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskSpec { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskSpecArgs<'args>,
            ) -> flatbuffers::WIPOffset<TaskSpec<'bldr>> {
                let mut builder = TaskSpecBuilder::new(_fbb);
                if let Some(x) = args.ready_indicator {
                    builder.add_ready_indicator(x);
                }
                if let Some(x) = args.dependencies {
                    builder.add_dependencies(x);
                }
                if let Some(x) = args.config {
                    builder.add_config(x);
                }
                builder.add_ignore_dependencies_error(args.ignore_dependencies_error);
                builder.add_terminate_after_dependents_finished(
                    args.terminate_after_dependents_finished,
                );
                builder.add_ready_indicator_source(args.ready_indicator_source);
                builder.add_pty(args.pty);
                builder.add_shell(args.shell);
                builder.finish()
            }

            #[inline]
            pub fn config(&self) -> TaskConfig<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TaskConfig>>(TaskSpec::VT_CONFIG, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn shell(&self) -> TaskShell {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskShell>(TaskSpec::VT_SHELL, Some(TaskShell::None))
                        .unwrap()
                }
            }
            #[inline]
            pub fn pty(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TaskSpec::VT_PTY, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn dependencies(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(TaskSpec::VT_DEPENDENCIES, None)
                }
            }
            #[inline]
            pub fn ready_indicator(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        TaskSpec::VT_READY_INDICATOR,
                        None,
                    )
                }
            }
            #[inline]
            pub fn ready_indicator_source(&self) -> StreamSource {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<StreamSource>(
                            TaskSpec::VT_READY_INDICATOR_SOURCE,
                            Some(StreamSource::Stdout),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn terminate_after_dependents_finished(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(
                            TaskSpec::VT_TERMINATE_AFTER_DEPENDENTS_FINISHED,
                            Some(false),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn ignore_dependencies_error(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TaskSpec::VT_IGNORE_DEPENDENCIES_ERROR, Some(false))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TaskSpec<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<TaskConfig>>(
                        "config",
                        Self::VT_CONFIG,
                        true,
                    )?
                    .visit_field::<TaskShell>("shell", Self::VT_SHELL, false)?
                    .visit_field::<bool>("pty", Self::VT_PTY, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                    >>("dependencies", Self::VT_DEPENDENCIES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "ready_indicator",
                        Self::VT_READY_INDICATOR,
                        false,
                    )?
                    .visit_field::<StreamSource>(
                        "ready_indicator_source",
                        Self::VT_READY_INDICATOR_SOURCE,
                        false,
                    )?
                    .visit_field::<bool>(
                        "terminate_after_dependents_finished",
                        Self::VT_TERMINATE_AFTER_DEPENDENTS_FINISHED,
                        false,
                    )?
                    .visit_field::<bool>(
                        "ignore_dependencies_error",
                        Self::VT_IGNORE_DEPENDENCIES_ERROR,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskSpecArgs<'a> {
            pub config: Option<flatbuffers::WIPOffset<TaskConfig<'a>>>,
            pub shell: TaskShell,
            pub pty: bool,
            pub dependencies: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >,
            >,
            pub ready_indicator: Option<flatbuffers::WIPOffset<&'a str>>,
            pub ready_indicator_source: StreamSource,
            pub terminate_after_dependents_finished: bool,
            pub ignore_dependencies_error: bool,
        }
        impl<'a> Default for TaskSpecArgs<'a> {
            #[inline]
            fn default() -> Self {
                TaskSpecArgs {
                    config: None, // required field
                    shell: TaskShell::None,
                    pty: false,
                    dependencies: None,
                    ready_indicator: None,
                    ready_indicator_source: StreamSource::Stdout,
                    terminate_after_dependents_finished: false,
                    ignore_dependencies_error: false,
                }
            }
        }

        pub struct TaskSpecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskSpecBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_config(&mut self, config: flatbuffers::WIPOffset<TaskConfig<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TaskConfig>>(
                        TaskSpec::VT_CONFIG,
                        config,
                    );
            }
            #[inline]
            pub fn add_shell(&mut self, shell: TaskShell) {
                self.fbb_
                    .push_slot::<TaskShell>(TaskSpec::VT_SHELL, shell, TaskShell::None);
            }
            #[inline]
            pub fn add_pty(&mut self, pty: bool) {
                self.fbb_.push_slot::<bool>(TaskSpec::VT_PTY, pty, false);
            }
            #[inline]
            pub fn add_dependencies(
                &mut self,
                dependencies: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskSpec::VT_DEPENDENCIES,
                    dependencies,
                );
            }
            #[inline]
            pub fn add_ready_indicator(
                &mut self,
                ready_indicator: flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskSpec::VT_READY_INDICATOR,
                    ready_indicator,
                );
            }
            #[inline]
            pub fn add_ready_indicator_source(&mut self, ready_indicator_source: StreamSource) {
                self.fbb_.push_slot::<StreamSource>(
                    TaskSpec::VT_READY_INDICATOR_SOURCE,
                    ready_indicator_source,
                    StreamSource::Stdout,
                );
            }
            #[inline]
            pub fn add_terminate_after_dependents_finished(
                &mut self,
                terminate_after_dependents_finished: bool,
            ) {
                self.fbb_.push_slot::<bool>(
                    TaskSpec::VT_TERMINATE_AFTER_DEPENDENTS_FINISHED,
                    terminate_after_dependents_finished,
                    false,
                );
            }
            #[inline]
            pub fn add_ignore_dependencies_error(&mut self, ignore_dependencies_error: bool) {
                self.fbb_.push_slot::<bool>(
                    TaskSpec::VT_IGNORE_DEPENDENCIES_ERROR,
                    ignore_dependencies_error,
                    false,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskSpecBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskSpecBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskSpec<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskSpec::VT_CONFIG, "config");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskSpec<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskSpec");
                ds.field("config", &self.config());
                ds.field("shell", &self.shell());
                ds.field("pty", &self.pty());
                ds.field("dependencies", &self.dependencies());
                ds.field("ready_indicator", &self.ready_indicator());
                ds.field("ready_indicator_source", &self.ready_indicator_source());
                ds.field(
                    "terminate_after_dependents_finished",
                    &self.terminate_after_dependents_finished(),
                );
                ds.field(
                    "ignore_dependencies_error",
                    &self.ignore_dependencies_error(),
                );
                ds.finish()
            }
        }
        pub enum TaskEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskEntry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskEntry<'a> {
            type Inner = TaskEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TaskEntry<'a> {
            pub const VT_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_SPEC: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskEntryArgs<'args>,
            ) -> flatbuffers::WIPOffset<TaskEntry<'bldr>> {
                let mut builder = TaskEntryBuilder::new(_fbb);
                if let Some(x) = args.spec {
                    builder.add_spec(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(TaskEntry::VT_NAME, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn spec(&self) -> TaskSpec<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TaskSpec>>(TaskEntry::VT_SPEC, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TaskEntry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
                    .visit_field::<flatbuffers::ForwardsUOffset<TaskSpec>>(
                        "spec",
                        Self::VT_SPEC,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskEntryArgs<'a> {
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub spec: Option<flatbuffers::WIPOffset<TaskSpec<'a>>>,
        }
        impl<'a> Default for TaskEntryArgs<'a> {
            #[inline]
            fn default() -> Self {
                TaskEntryArgs {
                    name: None, // required field
                    spec: None, // required field
                }
            }
        }

        pub struct TaskEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskEntry::VT_NAME, name);
            }
            #[inline]
            pub fn add_spec(&mut self, spec: flatbuffers::WIPOffset<TaskSpec<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TaskSpec>>(TaskEntry::VT_SPEC, spec);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskEntry::VT_NAME, "name");
                self.fbb_.required(o, TaskEntry::VT_SPEC, "spec");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskEntry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskEntry");
                ds.field("name", &self.name());
                ds.field("spec", &self.spec());
                ds.finish()
            }
        }
        pub enum TcrmTasksOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TcrmTasks<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TcrmTasks<'a> {
            type Inner = TcrmTasks<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TcrmTasks<'a> {
            pub const VT_TASKS: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TcrmTasks { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TcrmTasksArgs<'args>,
            ) -> flatbuffers::WIPOffset<TcrmTasks<'bldr>> {
                let mut builder = TcrmTasksBuilder::new(_fbb);
                if let Some(x) = args.tasks {
                    builder.add_tasks(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn tasks(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TaskEntry<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TaskEntry>>,
                    >>(TcrmTasks::VT_TASKS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for TcrmTasks<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TaskEntry>>,
                    >>("tasks", Self::VT_TASKS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TcrmTasksArgs<'a> {
            pub tasks: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TaskEntry<'a>>>,
                >,
            >,
        }
        impl<'a> Default for TcrmTasksArgs<'a> {
            #[inline]
            fn default() -> Self {
                TcrmTasksArgs { tasks: None }
            }
        }

        pub struct TcrmTasksBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TcrmTasksBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_tasks(
                &mut self,
                tasks: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TaskEntry<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TcrmTasks::VT_TASKS, tasks);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TcrmTasksBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TcrmTasksBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TcrmTasks<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TcrmTasks<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TcrmTasks");
                ds.field("tasks", &self.tasks());
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `TcrmTasks`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_tcrm_tasks_unchecked`.
        pub fn root_as_tcrm_tasks(
            buf: &'_ [u8],
        ) -> Result<TcrmTasks<'_>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<TcrmTasks>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `TcrmTasks` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_tcrm_tasks_unchecked`.
        pub fn size_prefixed_root_as_tcrm_tasks(
            buf: &'_ [u8],
        ) -> Result<TcrmTasks<'_>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<TcrmTasks>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `TcrmTasks` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_tcrm_tasks_unchecked`.
        pub fn root_as_tcrm_tasks_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TcrmTasks<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<TcrmTasks<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `TcrmTasks` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_tcrm_tasks_unchecked`.
        pub fn size_prefixed_root_as_tcrm_tasks_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TcrmTasks<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<TcrmTasks<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a TcrmTasks and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `TcrmTasks`.
        pub unsafe fn root_as_tcrm_tasks_unchecked(buf: &'_ [u8]) -> TcrmTasks<'_> {
            unsafe { flatbuffers::root_unchecked::<TcrmTasks>(buf) }
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed TcrmTasks and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `TcrmTasks`.
        pub unsafe fn size_prefixed_root_as_tcrm_tasks_unchecked(buf: &'_ [u8]) -> TcrmTasks<'_> {
            unsafe { flatbuffers::size_prefixed_root_unchecked::<TcrmTasks>(buf) }
        }
        #[inline]
        pub fn finish_tcrm_tasks_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<TcrmTasks<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_tcrm_tasks_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<TcrmTasks<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod Monitor
} // pub mod TCRM
