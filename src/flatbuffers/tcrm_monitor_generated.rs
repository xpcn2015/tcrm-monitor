// automatically generated by the FlatBuffers compiler, do not modify

// @generated
#![allow(clippy::extra_unused_lifetimes)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::missing_panics_doc)]
#![allow(clippy::missing_errors_doc)]
#![allow(clippy::must_use_candidate)]
#![allow(clippy::used_underscore_binding)]
#![allow(clippy::pub_underscore_fields)]
#![allow(clippy::elidable_lifetime_names)]
#![allow(clippy::doc_markdown)]
#![allow(clippy::too_many_lines)]

use tcrm_task::flatbuffers::tcrm_task_generated::*;

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tcrm {

    use core::cmp::Ordering;
    use core::mem;
    use tcrm_task::flatbuffers::tcrm_task_generated::*;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod monitor {

        use core::cmp::Ordering;
        use core::mem;
        use tcrm_task::flatbuffers::tcrm_task_generated::{
            tcrm::task::{TaskConfig, TaskEvent},
            *,
        };

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_SEND_STDIN_ERROR_REASON: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_SEND_STDIN_ERROR_REASON: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_SEND_STDIN_ERROR_REASON: [SendStdinErrorReason; 4] = [
            SendStdinErrorReason::TaskNotFound,
            SendStdinErrorReason::StdinNotEnabled,
            SendStdinErrorReason::TaskNotActive,
            SendStdinErrorReason::ChannelClosed,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct SendStdinErrorReason(pub i8);
        #[allow(non_upper_case_globals)]
        impl SendStdinErrorReason {
            pub const TaskNotFound: Self = Self(0);
            pub const StdinNotEnabled: Self = Self(1);
            pub const TaskNotActive: Self = Self(2);
            pub const ChannelClosed: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::TaskNotFound,
                Self::StdinNotEnabled,
                Self::TaskNotActive,
                Self::ChannelClosed,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::TaskNotFound => Some("TaskNotFound"),
                    Self::StdinNotEnabled => Some("StdinNotEnabled"),
                    Self::TaskNotActive => Some("TaskNotActive"),
                    Self::ChannelClosed => Some("ChannelClosed"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for SendStdinErrorReason {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for SendStdinErrorReason {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                    Self(b)
                }
            }
        }

        impl flatbuffers::Push for SendStdinErrorReason {
            type Output = SendStdinErrorReason;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<i8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for SendStdinErrorReason {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for SendStdinErrorReason {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for SendStdinErrorReason {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_CONTROL_COMMAND_ERROR_UNION: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_CONTROL_COMMAND_ERROR_UNION: u8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_CONTROL_COMMAND_ERROR_UNION: [ControlCommandErrorUnion; 4] = [
            ControlCommandErrorUnion::NONE,
            ControlCommandErrorUnion::TerminateAllTasks,
            ControlCommandErrorUnion::TerminateTask,
            ControlCommandErrorUnion::SendStdin,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct ControlCommandErrorUnion(pub u8);
        #[allow(non_upper_case_globals)]
        impl ControlCommandErrorUnion {
            pub const NONE: Self = Self(0);
            pub const TerminateAllTasks: Self = Self(1);
            pub const TerminateTask: Self = Self(2);
            pub const SendStdin: Self = Self(3);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::TerminateAllTasks,
                Self::TerminateTask,
                Self::SendStdin,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::TerminateAllTasks => Some("TerminateAllTasks"),
                    Self::TerminateTask => Some("TerminateTask"),
                    Self::SendStdin => Some("SendStdin"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for ControlCommandErrorUnion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for ControlCommandErrorUnion {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                    Self(b)
                }
            }
        }

        impl flatbuffers::Push for ControlCommandErrorUnion {
            type Output = ControlCommandErrorUnion;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for ControlCommandErrorUnion {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for ControlCommandErrorUnion {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for ControlCommandErrorUnion {}
        pub struct ControlCommandErrorUnionUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_MONITOR_ERROR_UNION: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_MONITOR_ERROR_UNION: u8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_MONITOR_ERROR_UNION: [TaskMonitorErrorUnion; 5] = [
            TaskMonitorErrorUnion::NONE,
            TaskMonitorErrorUnion::ConfigParse,
            TaskMonitorErrorUnion::CircularDependency,
            TaskMonitorErrorUnion::DependencyNotFound,
            TaskMonitorErrorUnion::ControlError,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskMonitorErrorUnion(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskMonitorErrorUnion {
            pub const NONE: Self = Self(0);
            pub const ConfigParse: Self = Self(1);
            pub const CircularDependency: Self = Self(2);
            pub const DependencyNotFound: Self = Self(3);
            pub const ControlError: Self = Self(4);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::ConfigParse,
                Self::CircularDependency,
                Self::DependencyNotFound,
                Self::ControlError,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::ConfigParse => Some("ConfigParse"),
                    Self::CircularDependency => Some("CircularDependency"),
                    Self::DependencyNotFound => Some("DependencyNotFound"),
                    Self::ControlError => Some("ControlError"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskMonitorErrorUnion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskMonitorErrorUnion {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                    Self(b)
                }
            }
        }

        impl flatbuffers::Push for TaskMonitorErrorUnion {
            type Output = TaskMonitorErrorUnion;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for TaskMonitorErrorUnion {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskMonitorErrorUnion {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskMonitorErrorUnion {}
        pub struct TaskMonitorErrorUnionUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_MONITOR_CONTROL_COMMAND: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_MONITOR_CONTROL_COMMAND: u8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_MONITOR_CONTROL_COMMAND: [TaskMonitorControlCommand; 4] = [
            TaskMonitorControlCommand::NONE,
            TaskMonitorControlCommand::TerminateAllTasks,
            TaskMonitorControlCommand::TerminateTask,
            TaskMonitorControlCommand::SendStdin,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskMonitorControlCommand(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskMonitorControlCommand {
            pub const NONE: Self = Self(0);
            pub const TerminateAllTasks: Self = Self(1);
            pub const TerminateTask: Self = Self(2);
            pub const SendStdin: Self = Self(3);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::TerminateAllTasks,
                Self::TerminateTask,
                Self::SendStdin,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::TerminateAllTasks => Some("TerminateAllTasks"),
                    Self::TerminateTask => Some("TerminateTask"),
                    Self::SendStdin => Some("SendStdin"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskMonitorControlCommand {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskMonitorControlCommand {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                    Self(b)
                }
            }
        }

        impl flatbuffers::Push for TaskMonitorControlCommand {
            type Output = TaskMonitorControlCommand;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for TaskMonitorControlCommand {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskMonitorControlCommand {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskMonitorControlCommand {}
        pub struct TaskMonitorControlCommandUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_MONITOR_CONTROL_EVENT_UNION: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_MONITOR_CONTROL_EVENT_UNION: u8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_MONITOR_CONTROL_EVENT_UNION: [TaskMonitorControlEventUnion; 3] = [
            TaskMonitorControlEventUnion::NONE,
            TaskMonitorControlEventUnion::ControlReceived,
            TaskMonitorControlEventUnion::ControlProcessed,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskMonitorControlEventUnion(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskMonitorControlEventUnion {
            pub const NONE: Self = Self(0);
            pub const ControlReceived: Self = Self(1);
            pub const ControlProcessed: Self = Self(2);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 2;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::NONE, Self::ControlReceived, Self::ControlProcessed];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::ControlReceived => Some("ControlReceived"),
                    Self::ControlProcessed => Some("ControlProcessed"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskMonitorControlEventUnion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskMonitorControlEventUnion {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                    Self(b)
                }
            }
        }

        impl flatbuffers::Push for TaskMonitorControlEventUnion {
            type Output = TaskMonitorControlEventUnion;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for TaskMonitorControlEventUnion {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskMonitorControlEventUnion {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskMonitorControlEventUnion {}
        pub struct TaskMonitorControlEventUnionUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_MONITOR_EVENT_UNION: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_MONITOR_EVENT_UNION: u8 = 5;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_MONITOR_EVENT_UNION: [TaskMonitorEventUnion; 6] = [
            TaskMonitorEventUnion::NONE,
            TaskMonitorEventUnion::Task,
            TaskMonitorEventUnion::Started,
            TaskMonitorEventUnion::Completed,
            TaskMonitorEventUnion::Control,
            TaskMonitorEventUnion::Error,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskMonitorEventUnion(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskMonitorEventUnion {
            pub const NONE: Self = Self(0);
            pub const Task: Self = Self(1);
            pub const Started: Self = Self(2);
            pub const Completed: Self = Self(3);
            pub const Control: Self = Self(4);
            pub const Error: Self = Self(5);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 5;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::Task,
                Self::Started,
                Self::Completed,
                Self::Control,
                Self::Error,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::Task => Some("Task"),
                    Self::Started => Some("Started"),
                    Self::Completed => Some("Completed"),
                    Self::Control => Some("Control"),
                    Self::Error => Some("Error"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskMonitorEventUnion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskMonitorEventUnion {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                    Self(b)
                }
            }
        }

        impl flatbuffers::Push for TaskMonitorEventUnion {
            type Output = TaskMonitorEventUnion;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for TaskMonitorEventUnion {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskMonitorEventUnion {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskMonitorEventUnion {}
        pub struct TaskMonitorEventUnionUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_SHELL: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_SHELL: i8 = 7;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_SHELL: [TaskShell; 8] = [
            TaskShell::None,
            TaskShell::Auto,
            TaskShell::Cmd,
            TaskShell::Powershell,
            TaskShell::Bash,
            TaskShell::Sh,
            TaskShell::Zsh,
            TaskShell::Fish,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskShell(pub i8);
        #[allow(non_upper_case_globals)]
        impl TaskShell {
            pub const None: Self = Self(0);
            pub const Auto: Self = Self(1);
            pub const Cmd: Self = Self(2);
            pub const Powershell: Self = Self(3);
            pub const Bash: Self = Self(4);
            pub const Sh: Self = Self(5);
            pub const Zsh: Self = Self(6);
            pub const Fish: Self = Self(7);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 7;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::None,
                Self::Auto,
                Self::Cmd,
                Self::Powershell,
                Self::Bash,
                Self::Sh,
                Self::Zsh,
                Self::Fish,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::None => Some("None"),
                    Self::Auto => Some("Auto"),
                    Self::Cmd => Some("Cmd"),
                    Self::Powershell => Some("Powershell"),
                    Self::Bash => Some("Bash"),
                    Self::Sh => Some("Sh"),
                    Self::Zsh => Some("Zsh"),
                    Self::Fish => Some("Fish"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskShell {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskShell {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                    Self(b)
                }
            }
        }

        impl flatbuffers::Push for TaskShell {
            type Output = TaskShell;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<i8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for TaskShell {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskShell {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskShell {}
        pub enum ConfigParseErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ConfigParseError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ConfigParseError<'a> {
            type Inner = ConfigParseError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> ConfigParseError<'a> {
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ConfigParseError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ConfigParseErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<ConfigParseError<'bldr>> {
                let mut builder = ConfigParseErrorBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn message(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            ConfigParseError::VT_MESSAGE,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ConfigParseError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ConfigParseErrorArgs<'a> {
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for ConfigParseErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                ConfigParseErrorArgs {
                    message: None, // required field
                }
            }
        }

        pub struct ConfigParseErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConfigParseErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ConfigParseError::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ConfigParseErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ConfigParseErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ConfigParseError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, ConfigParseError::VT_MESSAGE, "message");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ConfigParseError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ConfigParseError");
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum CircularDependencyErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CircularDependencyError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CircularDependencyError<'a> {
            type Inner = CircularDependencyError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> CircularDependencyError<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CircularDependencyError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CircularDependencyErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<CircularDependencyError<'bldr>> {
                let mut builder = CircularDependencyErrorBuilder::new(_fbb);
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            CircularDependencyError::VT_TASK_NAME,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for CircularDependencyError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct CircularDependencyErrorArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for CircularDependencyErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                CircularDependencyErrorArgs {
                    task_name: None, // required field
                }
            }
        }

        pub struct CircularDependencyErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CircularDependencyErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    CircularDependencyError::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CircularDependencyErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CircularDependencyErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CircularDependencyError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, CircularDependencyError::VT_TASK_NAME, "task_name");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CircularDependencyError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CircularDependencyError");
                ds.field("task_name", &self.task_name());
                ds.finish()
            }
        }
        pub enum DependencyNotFoundErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DependencyNotFoundError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DependencyNotFoundError<'a> {
            type Inner = DependencyNotFoundError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> DependencyNotFoundError<'a> {
            pub const VT_DEPENDENCY_TASK_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DependencyNotFoundError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args DependencyNotFoundErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<DependencyNotFoundError<'bldr>> {
                let mut builder = DependencyNotFoundErrorBuilder::new(_fbb);
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                if let Some(x) = args.dependency_task_name {
                    builder.add_dependency_task_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn dependency_task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            DependencyNotFoundError::VT_DEPENDENCY_TASK_NAME,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            DependencyNotFoundError::VT_TASK_NAME,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for DependencyNotFoundError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "dependency_task_name",
                        Self::VT_DEPENDENCY_TASK_NAME,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct DependencyNotFoundErrorArgs<'a> {
            pub dependency_task_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for DependencyNotFoundErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                DependencyNotFoundErrorArgs {
                    dependency_task_name: None, // required field
                    task_name: None,            // required field
                }
            }
        }

        pub struct DependencyNotFoundErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DependencyNotFoundErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_dependency_task_name(
                &mut self,
                dependency_task_name: flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DependencyNotFoundError::VT_DEPENDENCY_TASK_NAME,
                    dependency_task_name,
                );
            }
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DependencyNotFoundError::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> DependencyNotFoundErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                DependencyNotFoundErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DependencyNotFoundError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(
                    o,
                    DependencyNotFoundError::VT_DEPENDENCY_TASK_NAME,
                    "dependency_task_name",
                );
                self.fbb_
                    .required(o, DependencyNotFoundError::VT_TASK_NAME, "task_name");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DependencyNotFoundError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DependencyNotFoundError");
                ds.field("dependency_task_name", &self.dependency_task_name());
                ds.field("task_name", &self.task_name());
                ds.finish()
            }
        }
        pub enum TerminateAllTasksErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TerminateAllTasksError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TerminateAllTasksError<'a> {
            type Inner = TerminateAllTasksError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TerminateAllTasksError<'a> {
            pub const VT_REASON: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TerminateAllTasksError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TerminateAllTasksErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<TerminateAllTasksError<'bldr>> {
                let mut builder = TerminateAllTasksErrorBuilder::new(_fbb);
                if let Some(x) = args.reason {
                    builder.add_reason(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn reason(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            TerminateAllTasksError::VT_REASON,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TerminateAllTasksError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "reason",
                        Self::VT_REASON,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TerminateAllTasksErrorArgs<'a> {
            pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for TerminateAllTasksErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                TerminateAllTasksErrorArgs {
                    reason: None, // required field
                }
            }
        }

        pub struct TerminateAllTasksErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TerminateAllTasksErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TerminateAllTasksError::VT_REASON,
                    reason,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TerminateAllTasksErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TerminateAllTasksErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TerminateAllTasksError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, TerminateAllTasksError::VT_REASON, "reason");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TerminateAllTasksError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TerminateAllTasksError");
                ds.field("reason", &self.reason());
                ds.finish()
            }
        }
        pub enum TerminateTaskErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TerminateTaskError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TerminateTaskError<'a> {
            type Inner = TerminateTaskError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TerminateTaskError<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_REASON: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TerminateTaskError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TerminateTaskErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<TerminateTaskError<'bldr>> {
                let mut builder = TerminateTaskErrorBuilder::new(_fbb);
                if let Some(x) = args.reason {
                    builder.add_reason(x);
                }
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            TerminateTaskError::VT_TASK_NAME,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn reason(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            TerminateTaskError::VT_REASON,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TerminateTaskError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "reason",
                        Self::VT_REASON,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TerminateTaskErrorArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for TerminateTaskErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                TerminateTaskErrorArgs {
                    task_name: None, // required field
                    reason: None,    // required field
                }
            }
        }

        pub struct TerminateTaskErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TerminateTaskErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TerminateTaskError::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TerminateTaskError::VT_REASON,
                    reason,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TerminateTaskErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TerminateTaskErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TerminateTaskError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, TerminateTaskError::VT_TASK_NAME, "task_name");
                self.fbb_
                    .required(o, TerminateTaskError::VT_REASON, "reason");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TerminateTaskError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TerminateTaskError");
                ds.field("task_name", &self.task_name());
                ds.field("reason", &self.reason());
                ds.finish()
            }
        }
        pub enum SendStdinErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SendStdinError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SendStdinError<'a> {
            type Inner = SendStdinError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> SendStdinError<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_INPUT: flatbuffers::VOffsetT = 6;
            pub const VT_REASON: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SendStdinError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SendStdinErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<SendStdinError<'bldr>> {
                let mut builder = SendStdinErrorBuilder::new(_fbb);
                if let Some(x) = args.input {
                    builder.add_input(x);
                }
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.add_reason(args.reason);
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            SendStdinError::VT_TASK_NAME,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn input(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(SendStdinError::VT_INPUT, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn reason(&self) -> SendStdinErrorReason {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<SendStdinErrorReason>(
                            SendStdinError::VT_REASON,
                            Some(SendStdinErrorReason::TaskNotFound),
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for SendStdinError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "input",
                        Self::VT_INPUT,
                        true,
                    )?
                    .visit_field::<SendStdinErrorReason>("reason", Self::VT_REASON, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SendStdinErrorArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub input: Option<flatbuffers::WIPOffset<&'a str>>,
            pub reason: SendStdinErrorReason,
        }
        impl<'a> Default for SendStdinErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                SendStdinErrorArgs {
                    task_name: None, // required field
                    input: None,     // required field
                    reason: SendStdinErrorReason::TaskNotFound,
                }
            }
        }

        pub struct SendStdinErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendStdinErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    SendStdinError::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn add_input(&mut self, input: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(SendStdinError::VT_INPUT, input);
            }
            #[inline]
            pub fn add_reason(&mut self, reason: SendStdinErrorReason) {
                self.fbb_.push_slot::<SendStdinErrorReason>(
                    SendStdinError::VT_REASON,
                    reason,
                    SendStdinErrorReason::TaskNotFound,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SendStdinErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SendStdinErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SendStdinError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, SendStdinError::VT_TASK_NAME, "task_name");
                self.fbb_.required(o, SendStdinError::VT_INPUT, "input");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SendStdinError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SendStdinError");
                ds.field("task_name", &self.task_name());
                ds.field("input", &self.input());
                ds.field("reason", &self.reason());
                ds.finish()
            }
        }
        pub enum ControlCommandErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ControlCommandError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ControlCommandError<'a> {
            type Inner = ControlCommandError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> ControlCommandError<'a> {
            pub const VT_ERROR_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_ERROR: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ControlCommandError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ControlCommandErrorArgs,
            ) -> flatbuffers::WIPOffset<ControlCommandError<'bldr>> {
                let mut builder = ControlCommandErrorBuilder::new(_fbb);
                if let Some(x) = args.error {
                    builder.add_error(x);
                }
                builder.add_error_type(args.error_type);
                builder.finish()
            }

            #[inline]
            pub fn error_type(&self) -> ControlCommandErrorUnion {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<ControlCommandErrorUnion>(
                            ControlCommandError::VT_ERROR_TYPE,
                            Some(ControlCommandErrorUnion::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn error(&self) -> flatbuffers::Table<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            ControlCommandError::VT_ERROR,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn error_as_terminate_all_tasks(&self) -> Option<TerminateAllTasksError<'a>> {
                if self.error_type() == ControlCommandErrorUnion::TerminateAllTasks {
                    let u = self.error();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TerminateAllTasksError::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn error_as_terminate_task(&self) -> Option<TerminateTaskError<'a>> {
                if self.error_type() == ControlCommandErrorUnion::TerminateTask {
                    let u = self.error();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TerminateTaskError::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn error_as_send_stdin(&self) -> Option<SendStdinError<'a>> {
                if self.error_type() == ControlCommandErrorUnion::SendStdin {
                    let u = self.error();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { SendStdinError::init_from_table(u) })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for ControlCommandError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<ControlCommandErrorUnion, _>("error_type", Self::VT_ERROR_TYPE, "error", Self::VT_ERROR, true, |key, v, pos| {
        match key {
          ControlCommandErrorUnion::TerminateAllTasks => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TerminateAllTasksError>>("ControlCommandErrorUnion::TerminateAllTasks", pos),
          ControlCommandErrorUnion::TerminateTask => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TerminateTaskError>>("ControlCommandErrorUnion::TerminateTask", pos),
          ControlCommandErrorUnion::SendStdin => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SendStdinError>>("ControlCommandErrorUnion::SendStdin", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct ControlCommandErrorArgs {
            pub error_type: ControlCommandErrorUnion,
            pub error: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for ControlCommandErrorArgs {
            #[inline]
            fn default() -> Self {
                ControlCommandErrorArgs {
                    error_type: ControlCommandErrorUnion::NONE,
                    error: None, // required field
                }
            }
        }

        pub struct ControlCommandErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ControlCommandErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_error_type(&mut self, error_type: ControlCommandErrorUnion) {
                self.fbb_.push_slot::<ControlCommandErrorUnion>(
                    ControlCommandError::VT_ERROR_TYPE,
                    error_type,
                    ControlCommandErrorUnion::NONE,
                );
            }
            #[inline]
            pub fn add_error(
                &mut self,
                error: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ControlCommandError::VT_ERROR,
                    error,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ControlCommandErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ControlCommandErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ControlCommandError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, ControlCommandError::VT_ERROR, "error");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ControlCommandError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ControlCommandError");
                ds.field("error_type", &self.error_type());
                match self.error_type() {
                    ControlCommandErrorUnion::TerminateAllTasks => {
                        if let Some(x) = self.error_as_terminate_all_tasks() {
                            ds.field("error", &x)
                        } else {
                            ds.field(
                                "error",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    ControlCommandErrorUnion::TerminateTask => {
                        if let Some(x) = self.error_as_terminate_task() {
                            ds.field("error", &x)
                        } else {
                            ds.field(
                                "error",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    ControlCommandErrorUnion::SendStdin => {
                        if let Some(x) = self.error_as_send_stdin() {
                            ds.field("error", &x)
                        } else {
                            ds.field(
                                "error",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("error", &x)
                    }
                };
                ds.finish()
            }
        }
        pub enum TerminateAllTasksCommandOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TerminateAllTasksCommand<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TerminateAllTasksCommand<'a> {
            type Inner = TerminateAllTasksCommand<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TerminateAllTasksCommand<'a> {
            pub const VT_REASON: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TerminateAllTasksCommand { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TerminateAllTasksCommandArgs<'args>,
            ) -> flatbuffers::WIPOffset<TerminateAllTasksCommand<'bldr>> {
                let mut builder = TerminateAllTasksCommandBuilder::new(_fbb);
                if let Some(x) = args.reason {
                    builder.add_reason(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn reason(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            TerminateAllTasksCommand::VT_REASON,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TerminateAllTasksCommand<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "reason",
                        Self::VT_REASON,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TerminateAllTasksCommandArgs<'a> {
            pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for TerminateAllTasksCommandArgs<'a> {
            #[inline]
            fn default() -> Self {
                TerminateAllTasksCommandArgs {
                    reason: None, // required field
                }
            }
        }

        pub struct TerminateAllTasksCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TerminateAllTasksCommandBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TerminateAllTasksCommand::VT_REASON,
                    reason,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TerminateAllTasksCommandBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TerminateAllTasksCommandBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TerminateAllTasksCommand<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, TerminateAllTasksCommand::VT_REASON, "reason");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TerminateAllTasksCommand<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TerminateAllTasksCommand");
                ds.field("reason", &self.reason());
                ds.finish()
            }
        }
        pub enum TerminateTaskCommandOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TerminateTaskCommand<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TerminateTaskCommand<'a> {
            type Inner = TerminateTaskCommand<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TerminateTaskCommand<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_REASON: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TerminateTaskCommand { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TerminateTaskCommandArgs<'args>,
            ) -> flatbuffers::WIPOffset<TerminateTaskCommand<'bldr>> {
                let mut builder = TerminateTaskCommandBuilder::new(_fbb);
                if let Some(x) = args.reason {
                    builder.add_reason(x);
                }
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            TerminateTaskCommand::VT_TASK_NAME,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn reason(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            TerminateTaskCommand::VT_REASON,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TerminateTaskCommand<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "reason",
                        Self::VT_REASON,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TerminateTaskCommandArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for TerminateTaskCommandArgs<'a> {
            #[inline]
            fn default() -> Self {
                TerminateTaskCommandArgs {
                    task_name: None, // required field
                    reason: None,    // required field
                }
            }
        }

        pub struct TerminateTaskCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TerminateTaskCommandBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TerminateTaskCommand::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TerminateTaskCommand::VT_REASON,
                    reason,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TerminateTaskCommandBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TerminateTaskCommandBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TerminateTaskCommand<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, TerminateTaskCommand::VT_TASK_NAME, "task_name");
                self.fbb_
                    .required(o, TerminateTaskCommand::VT_REASON, "reason");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TerminateTaskCommand<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TerminateTaskCommand");
                ds.field("task_name", &self.task_name());
                ds.field("reason", &self.reason());
                ds.finish()
            }
        }
        pub enum SendStdinCommandOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SendStdinCommand<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SendStdinCommand<'a> {
            type Inner = SendStdinCommand<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> SendStdinCommand<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_INPUT: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SendStdinCommand { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SendStdinCommandArgs<'args>,
            ) -> flatbuffers::WIPOffset<SendStdinCommand<'bldr>> {
                let mut builder = SendStdinCommandBuilder::new(_fbb);
                if let Some(x) = args.input {
                    builder.add_input(x);
                }
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            SendStdinCommand::VT_TASK_NAME,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn input(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(SendStdinCommand::VT_INPUT, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for SendStdinCommand<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "input",
                        Self::VT_INPUT,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct SendStdinCommandArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub input: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for SendStdinCommandArgs<'a> {
            #[inline]
            fn default() -> Self {
                SendStdinCommandArgs {
                    task_name: None, // required field
                    input: None,     // required field
                }
            }
        }

        pub struct SendStdinCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendStdinCommandBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    SendStdinCommand::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn add_input(&mut self, input: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    SendStdinCommand::VT_INPUT,
                    input,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SendStdinCommandBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SendStdinCommandBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SendStdinCommand<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, SendStdinCommand::VT_TASK_NAME, "task_name");
                self.fbb_.required(o, SendStdinCommand::VT_INPUT, "input");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SendStdinCommand<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SendStdinCommand");
                ds.field("task_name", &self.task_name());
                ds.field("input", &self.input());
                ds.finish()
            }
        }
        pub enum ControlReceivedEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ControlReceivedEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ControlReceivedEvent<'a> {
            type Inner = ControlReceivedEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> ControlReceivedEvent<'a> {
            pub const VT_CONTROL_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_CONTROL: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ControlReceivedEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ControlReceivedEventArgs,
            ) -> flatbuffers::WIPOffset<ControlReceivedEvent<'bldr>> {
                let mut builder = ControlReceivedEventBuilder::new(_fbb);
                if let Some(x) = args.control {
                    builder.add_control(x);
                }
                builder.add_control_type(args.control_type);
                builder.finish()
            }

            #[inline]
            pub fn control_type(&self) -> TaskMonitorControlCommand {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskMonitorControlCommand>(
                            ControlReceivedEvent::VT_CONTROL_TYPE,
                            Some(TaskMonitorControlCommand::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn control(&self) -> flatbuffers::Table<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            ControlReceivedEvent::VT_CONTROL,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn control_as_terminate_all_tasks(&self) -> Option<TerminateAllTasksCommand<'a>> {
                if self.control_type() == TaskMonitorControlCommand::TerminateAllTasks {
                    let u = self.control();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TerminateAllTasksCommand::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn control_as_terminate_task(&self) -> Option<TerminateTaskCommand<'a>> {
                if self.control_type() == TaskMonitorControlCommand::TerminateTask {
                    let u = self.control();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TerminateTaskCommand::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn control_as_send_stdin(&self) -> Option<SendStdinCommand<'a>> {
                if self.control_type() == TaskMonitorControlCommand::SendStdin {
                    let u = self.control();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { SendStdinCommand::init_from_table(u) })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for ControlReceivedEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<TaskMonitorControlCommand, _>("control_type", Self::VT_CONTROL_TYPE, "control", Self::VT_CONTROL, true, |key, v, pos| {
        match key {
          TaskMonitorControlCommand::TerminateAllTasks => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TerminateAllTasksCommand>>("TaskMonitorControlCommand::TerminateAllTasks", pos),
          TaskMonitorControlCommand::TerminateTask => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TerminateTaskCommand>>("TaskMonitorControlCommand::TerminateTask", pos),
          TaskMonitorControlCommand::SendStdin => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SendStdinCommand>>("TaskMonitorControlCommand::SendStdin", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct ControlReceivedEventArgs {
            pub control_type: TaskMonitorControlCommand,
            pub control: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for ControlReceivedEventArgs {
            #[inline]
            fn default() -> Self {
                ControlReceivedEventArgs {
                    control_type: TaskMonitorControlCommand::NONE,
                    control: None, // required field
                }
            }
        }

        pub struct ControlReceivedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ControlReceivedEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_control_type(&mut self, control_type: TaskMonitorControlCommand) {
                self.fbb_.push_slot::<TaskMonitorControlCommand>(
                    ControlReceivedEvent::VT_CONTROL_TYPE,
                    control_type,
                    TaskMonitorControlCommand::NONE,
                );
            }
            #[inline]
            pub fn add_control(
                &mut self,
                control: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ControlReceivedEvent::VT_CONTROL,
                    control,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ControlReceivedEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ControlReceivedEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ControlReceivedEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, ControlReceivedEvent::VT_CONTROL, "control");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ControlReceivedEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ControlReceivedEvent");
                ds.field("control_type", &self.control_type());
                match self.control_type() {
                    TaskMonitorControlCommand::TerminateAllTasks => {
                        if let Some(x) = self.control_as_terminate_all_tasks() {
                            ds.field("control", &x)
                        } else {
                            ds.field(
                                "control",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorControlCommand::TerminateTask => {
                        if let Some(x) = self.control_as_terminate_task() {
                            ds.field("control", &x)
                        } else {
                            ds.field(
                                "control",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorControlCommand::SendStdin => {
                        if let Some(x) = self.control_as_send_stdin() {
                            ds.field("control", &x)
                        } else {
                            ds.field(
                                "control",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("control", &x)
                    }
                };
                ds.finish()
            }
        }
        pub enum ControlProcessedEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ControlProcessedEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ControlProcessedEvent<'a> {
            type Inner = ControlProcessedEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> ControlProcessedEvent<'a> {
            pub const VT_CONTROL_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_CONTROL: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ControlProcessedEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ControlProcessedEventArgs,
            ) -> flatbuffers::WIPOffset<ControlProcessedEvent<'bldr>> {
                let mut builder = ControlProcessedEventBuilder::new(_fbb);
                if let Some(x) = args.control {
                    builder.add_control(x);
                }
                builder.add_control_type(args.control_type);
                builder.finish()
            }

            #[inline]
            pub fn control_type(&self) -> TaskMonitorControlCommand {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskMonitorControlCommand>(
                            ControlProcessedEvent::VT_CONTROL_TYPE,
                            Some(TaskMonitorControlCommand::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn control(&self) -> flatbuffers::Table<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            ControlProcessedEvent::VT_CONTROL,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn control_as_terminate_all_tasks(&self) -> Option<TerminateAllTasksCommand<'a>> {
                if self.control_type() == TaskMonitorControlCommand::TerminateAllTasks {
                    let u = self.control();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TerminateAllTasksCommand::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn control_as_terminate_task(&self) -> Option<TerminateTaskCommand<'a>> {
                if self.control_type() == TaskMonitorControlCommand::TerminateTask {
                    let u = self.control();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TerminateTaskCommand::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn control_as_send_stdin(&self) -> Option<SendStdinCommand<'a>> {
                if self.control_type() == TaskMonitorControlCommand::SendStdin {
                    let u = self.control();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { SendStdinCommand::init_from_table(u) })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for ControlProcessedEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<TaskMonitorControlCommand, _>("control_type", Self::VT_CONTROL_TYPE, "control", Self::VT_CONTROL, true, |key, v, pos| {
        match key {
          TaskMonitorControlCommand::TerminateAllTasks => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TerminateAllTasksCommand>>("TaskMonitorControlCommand::TerminateAllTasks", pos),
          TaskMonitorControlCommand::TerminateTask => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TerminateTaskCommand>>("TaskMonitorControlCommand::TerminateTask", pos),
          TaskMonitorControlCommand::SendStdin => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SendStdinCommand>>("TaskMonitorControlCommand::SendStdin", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct ControlProcessedEventArgs {
            pub control_type: TaskMonitorControlCommand,
            pub control: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for ControlProcessedEventArgs {
            #[inline]
            fn default() -> Self {
                ControlProcessedEventArgs {
                    control_type: TaskMonitorControlCommand::NONE,
                    control: None, // required field
                }
            }
        }

        pub struct ControlProcessedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ControlProcessedEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_control_type(&mut self, control_type: TaskMonitorControlCommand) {
                self.fbb_.push_slot::<TaskMonitorControlCommand>(
                    ControlProcessedEvent::VT_CONTROL_TYPE,
                    control_type,
                    TaskMonitorControlCommand::NONE,
                );
            }
            #[inline]
            pub fn add_control(
                &mut self,
                control: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ControlProcessedEvent::VT_CONTROL,
                    control,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ControlProcessedEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ControlProcessedEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ControlProcessedEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, ControlProcessedEvent::VT_CONTROL, "control");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ControlProcessedEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ControlProcessedEvent");
                ds.field("control_type", &self.control_type());
                match self.control_type() {
                    TaskMonitorControlCommand::TerminateAllTasks => {
                        if let Some(x) = self.control_as_terminate_all_tasks() {
                            ds.field("control", &x)
                        } else {
                            ds.field(
                                "control",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorControlCommand::TerminateTask => {
                        if let Some(x) = self.control_as_terminate_task() {
                            ds.field("control", &x)
                        } else {
                            ds.field(
                                "control",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorControlCommand::SendStdin => {
                        if let Some(x) = self.control_as_send_stdin() {
                            ds.field("control", &x)
                        } else {
                            ds.field(
                                "control",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("control", &x)
                    }
                };
                ds.finish()
            }
        }
        pub enum TaskMonitorControlEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskMonitorControlEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskMonitorControlEvent<'a> {
            type Inner = TaskMonitorControlEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TaskMonitorControlEvent<'a> {
            pub const VT_CONTROL_EVENT_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_CONTROL_EVENT: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskMonitorControlEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskMonitorControlEventArgs,
            ) -> flatbuffers::WIPOffset<TaskMonitorControlEvent<'bldr>> {
                let mut builder = TaskMonitorControlEventBuilder::new(_fbb);
                if let Some(x) = args.control_event {
                    builder.add_control_event(x);
                }
                builder.add_control_event_type(args.control_event_type);
                builder.finish()
            }

            #[inline]
            pub fn control_event_type(&self) -> TaskMonitorControlEventUnion {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskMonitorControlEventUnion>(
                            TaskMonitorControlEvent::VT_CONTROL_EVENT_TYPE,
                            Some(TaskMonitorControlEventUnion::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn control_event(&self) -> flatbuffers::Table<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            TaskMonitorControlEvent::VT_CONTROL_EVENT,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn control_event_as_control_received(&self) -> Option<ControlReceivedEvent<'a>> {
                if self.control_event_type() == TaskMonitorControlEventUnion::ControlReceived {
                    let u = self.control_event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ControlReceivedEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn control_event_as_control_processed(&self) -> Option<ControlProcessedEvent<'a>> {
                if self.control_event_type() == TaskMonitorControlEventUnion::ControlProcessed {
                    let u = self.control_event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ControlProcessedEvent::init_from_table(u) })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for TaskMonitorControlEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<TaskMonitorControlEventUnion, _>("control_event_type", Self::VT_CONTROL_EVENT_TYPE, "control_event", Self::VT_CONTROL_EVENT, true, |key, v, pos| {
        match key {
          TaskMonitorControlEventUnion::ControlReceived => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ControlReceivedEvent>>("TaskMonitorControlEventUnion::ControlReceived", pos),
          TaskMonitorControlEventUnion::ControlProcessed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ControlProcessedEvent>>("TaskMonitorControlEventUnion::ControlProcessed", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct TaskMonitorControlEventArgs {
            pub control_event_type: TaskMonitorControlEventUnion,
            pub control_event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for TaskMonitorControlEventArgs {
            #[inline]
            fn default() -> Self {
                TaskMonitorControlEventArgs {
                    control_event_type: TaskMonitorControlEventUnion::NONE,
                    control_event: None, // required field
                }
            }
        }

        pub struct TaskMonitorControlEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskMonitorControlEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_control_event_type(
                &mut self,
                control_event_type: TaskMonitorControlEventUnion,
            ) {
                self.fbb_.push_slot::<TaskMonitorControlEventUnion>(
                    TaskMonitorControlEvent::VT_CONTROL_EVENT_TYPE,
                    control_event_type,
                    TaskMonitorControlEventUnion::NONE,
                );
            }
            #[inline]
            pub fn add_control_event(
                &mut self,
                control_event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskMonitorControlEvent::VT_CONTROL_EVENT,
                    control_event,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskMonitorControlEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskMonitorControlEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskMonitorControlEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(
                    o,
                    TaskMonitorControlEvent::VT_CONTROL_EVENT,
                    "control_event",
                );
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskMonitorControlEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskMonitorControlEvent");
                ds.field("control_event_type", &self.control_event_type());
                match self.control_event_type() {
                    TaskMonitorControlEventUnion::ControlReceived => {
                        if let Some(x) = self.control_event_as_control_received() {
                            ds.field("control_event", &x)
                        } else {
                            ds.field(
                                "control_event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorControlEventUnion::ControlProcessed => {
                        if let Some(x) = self.control_event_as_control_processed() {
                            ds.field("control_event", &x)
                        } else {
                            ds.field(
                                "control_event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("control_event", &x)
                    }
                };
                ds.finish()
            }
        }
        pub enum ExecutionStartedEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ExecutionStartedEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ExecutionStartedEvent<'a> {
            type Inner = ExecutionStartedEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> ExecutionStartedEvent<'a> {
            pub const VT_TOTAL_TASKS: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ExecutionStartedEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ExecutionStartedEventArgs,
            ) -> flatbuffers::WIPOffset<ExecutionStartedEvent<'bldr>> {
                let mut builder = ExecutionStartedEventBuilder::new(_fbb);
                builder.add_total_tasks(args.total_tasks);
                builder.finish()
            }

            #[inline]
            pub fn total_tasks(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(ExecutionStartedEvent::VT_TOTAL_TASKS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ExecutionStartedEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("total_tasks", Self::VT_TOTAL_TASKS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct ExecutionStartedEventArgs {
            pub total_tasks: u64,
        }
        impl<'a> Default for ExecutionStartedEventArgs {
            #[inline]
            fn default() -> Self {
                ExecutionStartedEventArgs { total_tasks: 0 }
            }
        }

        pub struct ExecutionStartedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExecutionStartedEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_total_tasks(&mut self, total_tasks: u64) {
                self.fbb_
                    .push_slot::<u64>(ExecutionStartedEvent::VT_TOTAL_TASKS, total_tasks, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ExecutionStartedEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ExecutionStartedEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ExecutionStartedEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ExecutionStartedEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ExecutionStartedEvent");
                ds.field("total_tasks", &self.total_tasks());
                ds.finish()
            }
        }
        pub enum ExecutionCompletedEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ExecutionCompletedEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ExecutionCompletedEvent<'a> {
            type Inner = ExecutionCompletedEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> ExecutionCompletedEvent<'a> {
            pub const VT_COMPLETED_TASKS: flatbuffers::VOffsetT = 4;
            pub const VT_FAILED_TASKS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ExecutionCompletedEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ExecutionCompletedEventArgs,
            ) -> flatbuffers::WIPOffset<ExecutionCompletedEvent<'bldr>> {
                let mut builder = ExecutionCompletedEventBuilder::new(_fbb);
                builder.add_failed_tasks(args.failed_tasks);
                builder.add_completed_tasks(args.completed_tasks);
                builder.finish()
            }

            #[inline]
            pub fn completed_tasks(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(ExecutionCompletedEvent::VT_COMPLETED_TASKS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn failed_tasks(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(ExecutionCompletedEvent::VT_FAILED_TASKS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ExecutionCompletedEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("completed_tasks", Self::VT_COMPLETED_TASKS, false)?
                    .visit_field::<u64>("failed_tasks", Self::VT_FAILED_TASKS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct ExecutionCompletedEventArgs {
            pub completed_tasks: u64,
            pub failed_tasks: u64,
        }
        impl<'a> Default for ExecutionCompletedEventArgs {
            #[inline]
            fn default() -> Self {
                ExecutionCompletedEventArgs {
                    completed_tasks: 0,
                    failed_tasks: 0,
                }
            }
        }

        pub struct ExecutionCompletedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExecutionCompletedEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_completed_tasks(&mut self, completed_tasks: u64) {
                self.fbb_.push_slot::<u64>(
                    ExecutionCompletedEvent::VT_COMPLETED_TASKS,
                    completed_tasks,
                    0,
                );
            }
            #[inline]
            pub fn add_failed_tasks(&mut self, failed_tasks: u64) {
                self.fbb_.push_slot::<u64>(
                    ExecutionCompletedEvent::VT_FAILED_TASKS,
                    failed_tasks,
                    0,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ExecutionCompletedEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ExecutionCompletedEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ExecutionCompletedEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ExecutionCompletedEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ExecutionCompletedEvent");
                ds.field("completed_tasks", &self.completed_tasks());
                ds.field("failed_tasks", &self.failed_tasks());
                ds.finish()
            }
        }
        pub enum TaskMonitorErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskMonitorError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskMonitorError<'a> {
            type Inner = TaskMonitorError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TaskMonitorError<'a> {
            pub const VT_ERROR_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_ERROR: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskMonitorError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskMonitorErrorArgs,
            ) -> flatbuffers::WIPOffset<TaskMonitorError<'bldr>> {
                let mut builder = TaskMonitorErrorBuilder::new(_fbb);
                if let Some(x) = args.error {
                    builder.add_error(x);
                }
                builder.add_error_type(args.error_type);
                builder.finish()
            }

            #[inline]
            pub fn error_type(&self) -> TaskMonitorErrorUnion {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskMonitorErrorUnion>(
                            TaskMonitorError::VT_ERROR_TYPE,
                            Some(TaskMonitorErrorUnion::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn error(&self) -> flatbuffers::Table<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            TaskMonitorError::VT_ERROR,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn error_as_config_parse(&self) -> Option<ConfigParseError<'a>> {
                if self.error_type() == TaskMonitorErrorUnion::ConfigParse {
                    let u = self.error();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ConfigParseError::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn error_as_circular_dependency(&self) -> Option<CircularDependencyError<'a>> {
                if self.error_type() == TaskMonitorErrorUnion::CircularDependency {
                    let u = self.error();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { CircularDependencyError::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn error_as_dependency_not_found(&self) -> Option<DependencyNotFoundError<'a>> {
                if self.error_type() == TaskMonitorErrorUnion::DependencyNotFound {
                    let u = self.error();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { DependencyNotFoundError::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn error_as_control_error(&self) -> Option<ControlCommandError<'a>> {
                if self.error_type() == TaskMonitorErrorUnion::ControlError {
                    let u = self.error();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ControlCommandError::init_from_table(u) })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for TaskMonitorError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<TaskMonitorErrorUnion, _>("error_type", Self::VT_ERROR_TYPE, "error", Self::VT_ERROR, true, |key, v, pos| {
        match key {
          TaskMonitorErrorUnion::ConfigParse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConfigParseError>>("TaskMonitorErrorUnion::ConfigParse", pos),
          TaskMonitorErrorUnion::CircularDependency => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CircularDependencyError>>("TaskMonitorErrorUnion::CircularDependency", pos),
          TaskMonitorErrorUnion::DependencyNotFound => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DependencyNotFoundError>>("TaskMonitorErrorUnion::DependencyNotFound", pos),
          TaskMonitorErrorUnion::ControlError => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ControlCommandError>>("TaskMonitorErrorUnion::ControlError", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct TaskMonitorErrorArgs {
            pub error_type: TaskMonitorErrorUnion,
            pub error: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for TaskMonitorErrorArgs {
            #[inline]
            fn default() -> Self {
                TaskMonitorErrorArgs {
                    error_type: TaskMonitorErrorUnion::NONE,
                    error: None, // required field
                }
            }
        }

        pub struct TaskMonitorErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskMonitorErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_error_type(&mut self, error_type: TaskMonitorErrorUnion) {
                self.fbb_.push_slot::<TaskMonitorErrorUnion>(
                    TaskMonitorError::VT_ERROR_TYPE,
                    error_type,
                    TaskMonitorErrorUnion::NONE,
                );
            }
            #[inline]
            pub fn add_error(
                &mut self,
                error: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskMonitorError::VT_ERROR,
                    error,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskMonitorErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskMonitorErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskMonitorError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskMonitorError::VT_ERROR, "error");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskMonitorError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskMonitorError");
                ds.field("error_type", &self.error_type());
                match self.error_type() {
                    TaskMonitorErrorUnion::ConfigParse => {
                        if let Some(x) = self.error_as_config_parse() {
                            ds.field("error", &x)
                        } else {
                            ds.field(
                                "error",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorErrorUnion::CircularDependency => {
                        if let Some(x) = self.error_as_circular_dependency() {
                            ds.field("error", &x)
                        } else {
                            ds.field(
                                "error",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorErrorUnion::DependencyNotFound => {
                        if let Some(x) = self.error_as_dependency_not_found() {
                            ds.field("error", &x)
                        } else {
                            ds.field(
                                "error",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorErrorUnion::ControlError => {
                        if let Some(x) = self.error_as_control_error() {
                            ds.field("error", &x)
                        } else {
                            ds.field(
                                "error",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("error", &x)
                    }
                };
                ds.finish()
            }
        }
        pub enum TaskMonitorEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskMonitorEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskMonitorEvent<'a> {
            type Inner = TaskMonitorEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TaskMonitorEvent<'a> {
            pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_EVENT: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskMonitorEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskMonitorEventArgs,
            ) -> flatbuffers::WIPOffset<TaskMonitorEvent<'bldr>> {
                let mut builder = TaskMonitorEventBuilder::new(_fbb);
                if let Some(x) = args.event {
                    builder.add_event(x);
                }
                builder.add_event_type(args.event_type);
                builder.finish()
            }

            #[inline]
            pub fn event_type(&self) -> TaskMonitorEventUnion {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskMonitorEventUnion>(
                            TaskMonitorEvent::VT_EVENT_TYPE,
                            Some(TaskMonitorEventUnion::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn event(&self) -> flatbuffers::Table<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            TaskMonitorEvent::VT_EVENT,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_task(&self) -> Option<TaskEvent<'a>> {
                if self.event_type() == TaskMonitorEventUnion::Task {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TaskEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_started(&self) -> Option<ExecutionStartedEvent<'a>> {
                if self.event_type() == TaskMonitorEventUnion::Started {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ExecutionStartedEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_completed(&self) -> Option<ExecutionCompletedEvent<'a>> {
                if self.event_type() == TaskMonitorEventUnion::Completed {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ExecutionCompletedEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_control(&self) -> Option<TaskMonitorControlEvent<'a>> {
                if self.event_type() == TaskMonitorEventUnion::Control {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TaskMonitorControlEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_error(&self) -> Option<TaskMonitorError<'a>> {
                if self.event_type() == TaskMonitorEventUnion::Error {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TaskMonitorError::init_from_table(u) })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for TaskMonitorEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<TaskMonitorEventUnion, _>("event_type", Self::VT_EVENT_TYPE, "event", Self::VT_EVENT, true, |key, v, pos| {
        match key {
          TaskMonitorEventUnion::Task => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TaskEvent>>("TaskMonitorEventUnion::Task", pos),
          TaskMonitorEventUnion::Started => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecutionStartedEvent>>("TaskMonitorEventUnion::Started", pos),
          TaskMonitorEventUnion::Completed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecutionCompletedEvent>>("TaskMonitorEventUnion::Completed", pos),
          TaskMonitorEventUnion::Control => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TaskMonitorControlEvent>>("TaskMonitorEventUnion::Control", pos),
          TaskMonitorEventUnion::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TaskMonitorError>>("TaskMonitorEventUnion::Error", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct TaskMonitorEventArgs {
            pub event_type: TaskMonitorEventUnion,
            pub event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for TaskMonitorEventArgs {
            #[inline]
            fn default() -> Self {
                TaskMonitorEventArgs {
                    event_type: TaskMonitorEventUnion::NONE,
                    event: None, // required field
                }
            }
        }

        pub struct TaskMonitorEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskMonitorEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_event_type(&mut self, event_type: TaskMonitorEventUnion) {
                self.fbb_.push_slot::<TaskMonitorEventUnion>(
                    TaskMonitorEvent::VT_EVENT_TYPE,
                    event_type,
                    TaskMonitorEventUnion::NONE,
                );
            }
            #[inline]
            pub fn add_event(
                &mut self,
                event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskMonitorEvent::VT_EVENT,
                    event,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskMonitorEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskMonitorEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskMonitorEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskMonitorEvent::VT_EVENT, "event");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskMonitorEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskMonitorEvent");
                ds.field("event_type", &self.event_type());
                match self.event_type() {
                    TaskMonitorEventUnion::Task => {
                        if let Some(x) = self.event_as_task() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorEventUnion::Started => {
                        if let Some(x) = self.event_as_started() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorEventUnion::Completed => {
                        if let Some(x) = self.event_as_completed() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorEventUnion::Control => {
                        if let Some(x) = self.event_as_control() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskMonitorEventUnion::Error => {
                        if let Some(x) = self.event_as_error() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("event", &x)
                    }
                };
                ds.finish()
            }
        }
        pub enum TaskSpecOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskSpec<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskSpec<'a> {
            type Inner = TaskSpec<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TaskSpec<'a> {
            pub const VT_CONFIG: flatbuffers::VOffsetT = 4;
            pub const VT_SHELL: flatbuffers::VOffsetT = 6;
            pub const VT_DEPENDENCIES: flatbuffers::VOffsetT = 8;
            pub const VT_TERMINATE_AFTER_DEPENDENTS_FINISHED: flatbuffers::VOffsetT = 10;
            pub const VT_IGNORE_DEPENDENCIES_ERROR: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskSpec { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskSpecArgs<'args>,
            ) -> flatbuffers::WIPOffset<TaskSpec<'bldr>> {
                let mut builder = TaskSpecBuilder::new(_fbb);
                if let Some(x) = args.dependencies {
                    builder.add_dependencies(x);
                }
                if let Some(x) = args.config {
                    builder.add_config(x);
                }
                builder.add_ignore_dependencies_error(args.ignore_dependencies_error);
                builder.add_terminate_after_dependents_finished(
                    args.terminate_after_dependents_finished,
                );
                builder.add_shell(args.shell);
                builder.finish()
            }

            #[inline]
            pub fn config(&self) -> TaskConfig<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TaskConfig>>(TaskSpec::VT_CONFIG, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn shell(&self) -> TaskShell {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskShell>(TaskSpec::VT_SHELL, Some(TaskShell::None))
                        .unwrap()
                }
            }
            #[inline]
            pub fn dependencies(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(TaskSpec::VT_DEPENDENCIES, None)
                }
            }
            #[inline]
            pub fn terminate_after_dependents_finished(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(
                            TaskSpec::VT_TERMINATE_AFTER_DEPENDENTS_FINISHED,
                            Some(false),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn ignore_dependencies_error(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TaskSpec::VT_IGNORE_DEPENDENCIES_ERROR, Some(false))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TaskSpec<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<TaskConfig>>(
                        "config",
                        Self::VT_CONFIG,
                        true,
                    )?
                    .visit_field::<TaskShell>("shell", Self::VT_SHELL, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                    >>("dependencies", Self::VT_DEPENDENCIES, false)?
                    .visit_field::<bool>(
                        "terminate_after_dependents_finished",
                        Self::VT_TERMINATE_AFTER_DEPENDENTS_FINISHED,
                        false,
                    )?
                    .visit_field::<bool>(
                        "ignore_dependencies_error",
                        Self::VT_IGNORE_DEPENDENCIES_ERROR,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskSpecArgs<'a> {
            pub config: Option<flatbuffers::WIPOffset<TaskConfig<'a>>>,
            pub shell: TaskShell,
            pub dependencies: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >,
            >,
            pub terminate_after_dependents_finished: bool,
            pub ignore_dependencies_error: bool,
        }
        impl<'a> Default for TaskSpecArgs<'a> {
            #[inline]
            fn default() -> Self {
                TaskSpecArgs {
                    config: None, // required field
                    shell: TaskShell::None,
                    dependencies: None,
                    terminate_after_dependents_finished: false,
                    ignore_dependencies_error: false,
                }
            }
        }

        pub struct TaskSpecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskSpecBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_config(&mut self, config: flatbuffers::WIPOffset<TaskConfig<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TaskConfig>>(
                        TaskSpec::VT_CONFIG,
                        config,
                    );
            }
            #[inline]
            pub fn add_shell(&mut self, shell: TaskShell) {
                self.fbb_
                    .push_slot::<TaskShell>(TaskSpec::VT_SHELL, shell, TaskShell::None);
            }
            #[inline]
            pub fn add_dependencies(
                &mut self,
                dependencies: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskSpec::VT_DEPENDENCIES,
                    dependencies,
                );
            }
            #[inline]
            pub fn add_terminate_after_dependents_finished(
                &mut self,
                terminate_after_dependents_finished: bool,
            ) {
                self.fbb_.push_slot::<bool>(
                    TaskSpec::VT_TERMINATE_AFTER_DEPENDENTS_FINISHED,
                    terminate_after_dependents_finished,
                    false,
                );
            }
            #[inline]
            pub fn add_ignore_dependencies_error(&mut self, ignore_dependencies_error: bool) {
                self.fbb_.push_slot::<bool>(
                    TaskSpec::VT_IGNORE_DEPENDENCIES_ERROR,
                    ignore_dependencies_error,
                    false,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskSpecBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskSpecBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskSpec<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskSpec::VT_CONFIG, "config");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskSpec<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskSpec");
                ds.field("config", &self.config());
                ds.field("shell", &self.shell());
                ds.field("dependencies", &self.dependencies());
                ds.field(
                    "terminate_after_dependents_finished",
                    &self.terminate_after_dependents_finished(),
                );
                ds.field(
                    "ignore_dependencies_error",
                    &self.ignore_dependencies_error(),
                );
                ds.finish()
            }
        }
        pub enum TaskEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskEntry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskEntry<'a> {
            type Inner = TaskEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TaskEntry<'a> {
            pub const VT_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_SPEC: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskEntryArgs<'args>,
            ) -> flatbuffers::WIPOffset<TaskEntry<'bldr>> {
                let mut builder = TaskEntryBuilder::new(_fbb);
                if let Some(x) = args.spec {
                    builder.add_spec(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(TaskEntry::VT_NAME, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn spec(&self) -> TaskSpec<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TaskSpec>>(TaskEntry::VT_SPEC, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TaskEntry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
                    .visit_field::<flatbuffers::ForwardsUOffset<TaskSpec>>(
                        "spec",
                        Self::VT_SPEC,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskEntryArgs<'a> {
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub spec: Option<flatbuffers::WIPOffset<TaskSpec<'a>>>,
        }
        impl<'a> Default for TaskEntryArgs<'a> {
            #[inline]
            fn default() -> Self {
                TaskEntryArgs {
                    name: None, // required field
                    spec: None, // required field
                }
            }
        }

        pub struct TaskEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskEntry::VT_NAME, name);
            }
            #[inline]
            pub fn add_spec(&mut self, spec: flatbuffers::WIPOffset<TaskSpec<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TaskSpec>>(TaskEntry::VT_SPEC, spec);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskEntry::VT_NAME, "name");
                self.fbb_.required(o, TaskEntry::VT_SPEC, "spec");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskEntry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskEntry");
                ds.field("name", &self.name());
                ds.field("spec", &self.spec());
                ds.finish()
            }
        }
        pub enum TcrmTasksOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TcrmTasks<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TcrmTasks<'a> {
            type Inner = TcrmTasks<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe {
                    Self {
                        _tab: flatbuffers::Table::new(buf, loc),
                    }
                }
            }
        }

        impl<'a> TcrmTasks<'a> {
            pub const VT_TASKS: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TcrmTasks { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TcrmTasksArgs<'args>,
            ) -> flatbuffers::WIPOffset<TcrmTasks<'bldr>> {
                let mut builder = TcrmTasksBuilder::new(_fbb);
                if let Some(x) = args.tasks {
                    builder.add_tasks(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn tasks(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TaskEntry<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TaskEntry>>,
                    >>(TcrmTasks::VT_TASKS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for TcrmTasks<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TaskEntry>>,
                    >>("tasks", Self::VT_TASKS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TcrmTasksArgs<'a> {
            pub tasks: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TaskEntry<'a>>>,
                >,
            >,
        }
        impl<'a> Default for TcrmTasksArgs<'a> {
            #[inline]
            fn default() -> Self {
                TcrmTasksArgs { tasks: None }
            }
        }

        pub struct TcrmTasksBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TcrmTasksBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_tasks(
                &mut self,
                tasks: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TaskEntry<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TcrmTasks::VT_TASKS, tasks);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TcrmTasksBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TcrmTasksBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TcrmTasks<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TcrmTasks<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TcrmTasks");
                ds.field("tasks", &self.tasks());
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `TcrmTasks`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_tcrm_tasks_unchecked`.
        pub fn root_as_tcrm_tasks(
            buf: &'_ [u8],
        ) -> Result<TcrmTasks<'_>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<TcrmTasks>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `TcrmTasks` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_tcrm_tasks_unchecked`.
        pub fn size_prefixed_root_as_tcrm_tasks(
            buf: &'_ [u8],
        ) -> Result<TcrmTasks<'_>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<TcrmTasks>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `TcrmTasks` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_tcrm_tasks_unchecked`.
        pub fn root_as_tcrm_tasks_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TcrmTasks<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<TcrmTasks<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `TcrmTasks` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_tcrm_tasks_unchecked`.
        pub fn size_prefixed_root_as_tcrm_tasks_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TcrmTasks<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<TcrmTasks<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a TcrmTasks and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `TcrmTasks`.
        pub unsafe fn root_as_tcrm_tasks_unchecked(buf: &'_ [u8]) -> TcrmTasks<'_> {
            unsafe { flatbuffers::root_unchecked::<TcrmTasks>(buf) }
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed TcrmTasks and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `TcrmTasks`.
        pub unsafe fn size_prefixed_root_as_tcrm_tasks_unchecked(buf: &'_ [u8]) -> TcrmTasks<'_> {
            unsafe { flatbuffers::size_prefixed_root_unchecked::<TcrmTasks>(buf) }
        }
        #[inline]
        pub fn finish_tcrm_tasks_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<TcrmTasks<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_tcrm_tasks_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<TcrmTasks<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod Monitor
} // pub mod TCRM
